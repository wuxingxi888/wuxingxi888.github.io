---
title: Vite 和 Webpack 对比：新一代构建工具为何更快？
date: 2025-10-18 11:40:01
tags: vite webpack 前端构建工具 前端框架
categories: 前端框架
top_img:
cover: https://s2.loli.net/2024/02/02/8cRdqZbAUnhVeLE.webp
---

## 核心区别：构建理念的根本不同

最核心的区别可以概括为一句话：

**Webpack**：先打包，再启动开发服务器。

**Vite**：先启动开发服务器，再按需编译。

这个根本性的理念差异，导致了它们在开发体验上的巨大不同。下面我们通过一个流程图来直观感受：

{% mermaid %}
flowchart TD
A[开发者执行启动命令] --> B{使用哪个工具?}

    B -->|Webpack| C[开始打包]
    C --> D[递归构建依赖图<br>包含所有模块]
    D --> E[打包成 Bundle<br>内存/磁盘]
    E --> F[启动 Dev Server]
    F --> G[服务 Bundle 给浏览器]
    G --> H[页面加载完成]

    B -->|Vite| I[立即启动 Dev Server]
    I --> J{浏览器请求页面}
    J --> K[请求 HTML]
    K --> L[返回 HTML]
    L --> M[请求入口文件<br>如 main.js]
    M --> N[利用浏览器 ES Module<br>直接导入模块]
    N --> O{遇到新 import 请求?}
    O -->|是| P[Vite 服务器按需编译<br>仅编译该模块]
    P --> Q[返回编译后模块]
    O -->|否| R[页面加载完成]
    Q --> O

{% endmermaid %}

## Webpack 的运作方式（为什么慢？）

如上图左侧所示，Webpack 在启动开发服务器之前，必须先完成整个应用的打包过程。

1. **从入口文件开始**：比如 `src/index.js`。

2. **递归构建依赖图**：Webpack 会遍历你的所有代码，找出每一个 `import` 和 `require`，解析出整个项目的模块依赖关系树。这个过程涉及大量的文件 I/O 和代码分析。

3. **打包成一个或多个 Bundle**：将所有模块（包括你的源代码、node_modules 中的依赖）打包、转换（如 Babel 转译 JSX/TS）、合并成一个或几个大的 JavaScript 文件（bundle），存放在内存或磁盘中。

4. **启动 Dev Server**：服务器启动后，将这些打包好的 bundle 提供给浏览器。

**瓶颈所在**：

-   项目越大，依赖越多，构建依赖图和打包的过程就越长。即使你只修改一行代码，在启动时也需要处理整个项目。
-   冷启动体验非常差，你可能需要等待几十秒甚至几分钟才能看到页面。

## Vite 的运作方式（为什么快？）

如上图右侧所示，Vite 利用了现代浏览器原生支持的 ES Modules (ESM) 特性，彻底改变了这个流程。

### 核心原理：按需编译

1. **立即启动服务器**：当你运行 `vite` 命令时，Vite 会立即启动一个开发服务器，几乎无需等待。

2. **浏览器直接接管模块加载**：

    - 服务器返回你的 `index.html`。
    - HTML 中通过 `<script type="module" src="/src/main.js">` 加载你的入口文件。
    - 浏览器会解析 `main.js` 中的 `import` 语句，并向 Vite 服务器发起新的 HTTP 请求，来获取这些被导入的模块。

3. **服务器的按需转换**：
    - 当浏览器请求一个模块时（例如 `./App.vue` 或 `lodash-es`），Vite 的服务器才会在后端对这个模块进行编译和转换。
    - 它只编译当前浏览器请求的这一个文件，而不是整个项目。
    - 对于 `node_modules` 中的依赖，Vite 使用了 `esbuild`（用 Go 编写，比 JS 编写的打包器快 10-100 倍）进行依赖预构建，将其转换为 ESM 格式并缓存起来，后续无需再次处理。

## Vite 快的关键技术点

### No Bundle（无需打包）

在开发阶段，Vite 不需要将你的代码打包成一个整体。浏览器通过 ES Modules 自己来加载各个独立的模块文件。这省去了最耗时的打包环节。

### 按需编译

你访问哪个页面，浏览器就请求哪个模块，Vite 服务器就编译哪个模块。项目有 1000 个页面，启动时 Vite 只编译你首页用到的几十个模块，速度自然极快。

### Esbuild 预构建

**功能**：将 CommonJS/UMD 等格式的依赖转换为 ESM，并将多个内部有大量小模块的依赖（如 `lodash-es`）合并成一个文件，减少网络请求。

**性能**：使用 Go 编写的 esbuild 进行此操作，其速度远超基于 JavaScript 的打包器，将预构建时间从分钟级降到秒级。

### 高效缓存

-   预构建的依赖使用 `Cache-Control` 强缓存，只要依赖列表（package.json）不变，就永远不需要再次构建。
-   源码模块会根据情况设置适当的缓存头，提高二次启动速度。

## 对比表格

| 特性/方面     | Webpack                                        | Vite                                                      |
| ------------- | ---------------------------------------------- | --------------------------------------------------------- |
| 开发构建理念  | 打包（Bundle）优先                             | 按需编译（No-Bundle）                                     |
| 启动时间      | 随项目增大而线性增长，慢                       | 极快，与项目大小关系不大                                  |
| 热更新（HMR） | 需要重新打包变动的模块，模块越多速度越慢       | 只精确地更新变动的模块，速度极快，与项目大小无关          |
| 生产构建      | 自身处理，成熟稳定，可高度配置                 | 默认使用 Rollup（成熟且输出更优化），也可配置使用 Webpack |
| 适用场景      | 所有项目，特别是对打包流程有深度定制需求的项目 | 现代浏览器项目，追求极致开发体验，特别是大型项目          |

## 总结

Vite 启动快的核心原理是：

它颠覆了传统的"先打包后服务"模式，利用浏览器原生 ES Modules 的能力，实现了"服务与编译分离"。开发服务器立即启动，然后根据浏览器的请求，在服务器端进行按需、实时的编译。这种方式将巨大的初始打包成本分摊到了整个开发过程中，每次启动只需要处理极少量的模块，从而实现了"秒级"启动。

简单来说，Webpack 是 "厨师在开门前要把所有菜都做好"，而 Vite 是 "先开门迎客，客人点什么，厨师现做什么"。在大型项目中，后者的"冷启动"效率优势是压倒性的。
